<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Blue Archive – Cost Calculation Demo</title>
  <script src="TL-assistant-utils.js"></script>
  <style>
    /* --- Minimal, clean styling for quick inspection --- */
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP", sans-serif; margin: 24px; }
    h1 { font-size: 1.4rem; margin: 0 0 6px; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin: 12px 0 16px; }
    .btn { padding: 8px 12px; border-radius: 10px; border: 1px solid #ccc; background: #f7f7f7; cursor: pointer; }
    .btn.active { background: #e6f2ff; border-color: #7fb6ff; font-weight: 600; }
    table { border-collapse: collapse; width: 100%; }
    thead th { position: sticky; top: 0; background: #fff; }
    th, td { border: 1px solid #ddd; padding: 6px 8px; font-variant-numeric: tabular-nums; text-align: right; }
    th:first-child, td:first-child, th:nth-child(2), td:nth-child(2), th:nth-child(3), td:nth-child(3), th:nth-child(4), td:nth-child(4) { text-align: center; }
    caption { text-align: left; font-weight: 600; margin: 8px 0; }
    .muted { color: #666; font-size: 0.92rem; }
    .summary { margin: 10px 0 18px; }
    .nowrap { white-space: nowrap; }
    .cost-overflow { color: #d32f2f; font-weight: bold; }
    .remaining-cost { color: #1976d2; font-weight: bold; }
    .timeline-row { display: flex; }
    .timeline-event { flex: 0 0 200px; }
    .timeline-cost { flex: 1; }
    
    /* タイムライン入力・出力の横並びレイアウト */
    .timeline-container { display: flex; flex-direction: column; gap: 16px; }
    
    @media (min-width: 750px) {
      .timeline-container { flex-direction: row; }
      .timeline-input-section { flex: 0.4; margin-right: 8px; }
      #timelineInfo { flex: 0.6; margin-left: 8px; }
    }
  </style>
</head>
<body>
  <h1>ブルーアーカイブ TL作成アシスタント</h1>
  <h2 style="margin-top: 18px; font-size: 1.1rem; color: #1976d2;">記入方法</h2>
  <div class="muted">以下の要素を各行に含んでください：
    <ul>
      <li>使用タイムあるいはスキル使用前コスト（記入ない場合は最速）</li>
      <li>スキルあるいはイベント名</li>
      <li>スキル使用コスト（記入ない場合は0コスト扱い）</li>
    </ul>
コストはサンプルにあるように角かっこで囲むことが想定されています。例えば「[4]アコ[3]」は「4コスト溜まった段階で3コストを払いアコのスキルを使用する」と解釈されます。使用タイムとスキル使用前コストの両方が記入されている場合、タイムが優先されてコストは無視されます。
<h2 style="margin-top: 18px; font-size: 1.1rem; color: #1976d2;">コスト回復バフについて</h2>
「水着ホシノ」あるいは「水おじ」が記入されている場合自動でコスト回復バフに関するタイムスタンプが追加されます。セイアなどのスキルは順次対応予定です。
  </div>

<h2 style="margin-top: 18px; font-size: 1.1rem; color: #1976d2;">設定</h2>
  <div class="total time controls">
    <span>戦闘時間：</span>
    <button class="btn" data-tt="180">180秒</button>
    <button class="btn" data-tt="240">240秒</button>
    <span id="currentTT" class="muted"></span>
  </div>

  <div class="cost SS controls">
    <span>コスト回復量増加SS：</span>
    <button class="btn" data-ss="on">オン</button>
    <button class="btn" data-ss="off">オフ</button>
    <span id="currentSS" class="muted"></span>
  </div>
  
  <div class="cost limit controls">
    <span>最大コスト：</span>
    <button class="btn" data-limit="10">10</button>
    <button class="btn" data-limit="10.5">10.5</button>
    <button class="btn" data-limit="11">11</button>
    <span id="currentLimit" class="muted"></span>
  </div>


  <div class="timeline-container">
    <div class="timeline-input-section" style="margin: 12px 0; padding: 16px; background: #f0f8ff; border-radius: 8px; border: 1px solid #b3d9ff;">
      <h3 style="margin: 0 0 16px; font-size: 1.2rem; color: #1976d2;">タイムライン入力</h3>
      <div style="font-size: 0.85rem; color: #666; margin-bottom: 12px; font-style: italic;">（時間表記は自動判別：経過時間，ゲーム内表記両方可）</div>
      <div style="margin-bottom: 12px;">
        <label for="timelineInput" style="display: block; font-weight: 600; margin-bottom: 6px;">タイムラインデータ（テキスト形式）:</label>
        <textarea id="timelineInput" style="width: 100%; min-height: 200px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 0.9rem; resize: vertical; box-sizing: border-box;">2:43.212イオリ[3]
[9.3]水着ホシノ[5]
アイドルマリー[2]
2:12アコ[3]
[9.2]ヒマリ[3]
キャンプハレNS
1:59ミカ[6]
1:47.567〆</textarea>
      </div>
    </div>

    <div id="timelineInfo" style="margin: 12px 0; padding: 12px; background: #fff8e1; border-radius: 6px; line-height: 1.6; border: 1px solid #ffc947;"></div>
  </div>

  <table id="resultTable">
    <caption>詳細情報</caption>
    <thead>
      <tr>
        <th>経過フレーム</th>
        <th>経過時間(秒)</th>
        <th>ゲーム内時間表記</th>
        <th>イベント名</th>
        <th>総コスト回復量</th>
        <th>スキル使用前コスト</th>
        <th>スキル使用コスト</th>
        <th>スキル使用後コスト</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <div class="timeline-output-section" style="margin: 24px 0; padding: 16px; background: #f9f9f9; border-radius: 8px; border: 1px solid #ddd;">
    <h3 style="margin: 0 0 16px; font-size: 1.2rem; color: #666;">内部データ</h3>
    <pre id="timelineOutput" style="background: #f5f5f5; padding: 12px; border-radius: 4px; overflow-x: auto; font-size: 0.9rem; margin: 0; white-space: pre-wrap;"></pre>
  </div>

  <script>
    // ==============================
    // Constants per project spec
    // ==============================
    const FPS = 30;                       // 30 FPS
    const COST_DENOM = 30 * 10000;        // 300,000

    // グローバル変数
    let cost_limit = 10; // default
    let costPointLimit = Math.round(cost_limit * COST_DENOM); // コスト上限のポイント表現
    let totalTime = 180; // 戦闘時間（秒）デフォルト
    let processedInput = null; // 処理されたタイムライン入力

    // ==============================
    // Sample timeline (modifiable)
    // 各要素は { frame, cost_recovery, cost_used }
    // - その時点以降に有効になる cost_recovery を表す（次のノード直前まで）
    // - cost_used はそのフレーム時点で消費する「コスト（単位）」を表す
    // ==============================
    const timeline = [
      { frame: 0,   student_num: 0, cost_used: 0, cost_recovery_buff_list:[] },
      { frame: 60,  student_num: 6, cost_used: 0, cost_recovery_buff_list:[] },
      { frame: 671, student_num: 5, cost_used: 2, cost_recovery_buff_list:[321] },
      { frame: 724, student_num: 4, cost_used: 4, cost_recovery_buff_list:[] },
      { frame: 832, student_num: 4, cost_used: 0, cost_recovery_buff_list:[] },
    ];

    // ==============================
    // Core calculation
    // ==============================
    function computeRows() {
      // processedInputが存在する場合はそれを使用、なければsample timelineを使用
      const timelineData = (processedInput && processedInput.events && processedInput.events.length > 0) 
        ? processedInput.events 
        : timeline;

      let rows = [];
      let cost_point = 0; // integer accumulator in points

      for (let i = 1; i < timelineData.length; i++) {
        const current = timelineData[i];
        const previous = timelineData[i - 1];

        // 経過フレーム数
        const elapsed_frames = current.frame - previous.frame;
        
        // 適用される cost_recovery の計算
        const cost_recovery_SS_buff = 0.2029; // SS効果の係数
        const base_recovery = 700; // 基礎コスト回復値
        
        // バフのかかっていない生徒数
        const unbuffed_students = previous.student_num - previous.cost_recovery_buff_list.length;
        
        let total_cost_recovery = 0;
        
        // バフのかかっていない生徒のコスト回復量計算
        if (unbuffed_students > 0) {
          const unbuffed_base = base_recovery;
          const unbuffed_actual = ssEnabled ? Math.round(unbuffed_base * (1 + cost_recovery_SS_buff)) : unbuffed_base;
          total_cost_recovery += unbuffed_students * unbuffed_actual;
        }
        
        // バフのかかっている生徒のコスト回復量計算
        for (const buff of previous.cost_recovery_buff_list) {
          // バフがオブジェクトの場合とnumberの場合の両方に対応
          const buffValue = typeof buff === 'object' ? buff.buff_amount : buff;
          const buffed_base = base_recovery + buffValue;
          const buffed_actual = ssEnabled ? Math.round(buffed_base * (1 + cost_recovery_SS_buff)) : buffed_base;
          total_cost_recovery += buffed_actual;
        }
        
        const cost_recovery = total_cost_recovery;

        // コストポイント増加分
        const cost_point_before_spill = cost_point + elapsed_frames * cost_recovery;
        // コストポイントの上限適用：コスト溢れの処理
        cost_point = Math.min(cost_point_before_spill, costPointLimit);
        const cost_spilled = cost_point_before_spill - cost_point; // 溢れた分を記録（将来の拡張用）

        // スキル仕様前コスト
        const cost_before = cost_point / COST_DENOM;

        // 使用されるコスト
        const cost_used = current.cost_used || 0;

        // コストの使用（あるいは回復）
        const consume_points = Math.round(cost_used * COST_DENOM);
        cost_point = cost_point - consume_points;

        // スキル使用後コスト
        const cost_after = cost_point / COST_DENOM;

        // 残りコストポイントと使用総コストポイント
        const remaining_cost_points = costPointLimit - cost_point;
        const total_used_cost_points = consume_points;

        rows.push({
          frame: current.frame,
          time_sec: (current.frame / FPS),
          elapsed_frames,
          active_recovery: cost_recovery,
          cost_before,
          cost_used: cost_used,
          cost_after,
          cost_spilled: cost_spilled / COST_DENOM,
          event_name: current.event_name || '', // イベント名を追加
          remaining_cost_points: remaining_cost_points,
          total_used_cost_points: total_used_cost_points,
        });
      }

      return rows;
    }

    // ==============================
    // Rendering
    // ==============================
    const tbody = document.querySelector('#resultTable tbody');

    function renderTable(rows) {
      tbody.innerHTML = '';
      
      // タイムライン情報を更新
      const timelineInfoEl = document.getElementById('timelineInfo');
      let infoHTML = '<h3 style="margin: 0 0 12px 0; font-size: 1.1rem;">タイムライン(処理済)</h3>';
      
      for (let index = 0; index < rows.length; index++) {
        const r = rows[index];
        const tr = document.createElement('tr');

        // Helper for td creation with right alignment and fixed decimals if needed
        const td = (text) => { const el = document.createElement('td'); el.textContent = text; return el; };

        // 残り時間の計算（戦闘時間 - 経過時間）
        const remainingTime = totalTime - r.time_sec;
        const formatTime = (seconds) => {
          if (seconds <= 0) return "00:00.000";
          const minutes = Math.floor(seconds / 60);
          const secs = seconds % 60;
          const wholeSeconds = Math.floor(secs);
          const milliseconds = Math.round((secs - wholeSeconds) * 1000);
          return `${minutes.toString().padStart(2, '0')}:${wholeSeconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
        };

        // イベント名を取得（processedInputから）
        let eventName = '';
        if (processedInput && processedInput.events && processedInput.events[index + 1]) {
          const currentEvent = processedInput.events[index + 1];
          if (currentEvent && currentEvent.event_name) {
            eventName = currentEvent.event_name;
          }
        }

        // 行の情報を表示
        const gameTimeText = formatTime(remainingTime);
        const costBeforeText = r.cost_used > 0 ? `[${r.cost_before.toFixed(1)}]` : '';
        const remainingCostText = r.cost_after.toFixed(2);
        const overflowText = r.cost_spilled > 0 ? `<span class="cost-overflow">あふれたコスト：${r.cost_spilled.toFixed(2)}</span>` : '';
        
        infoHTML += `<div class="timeline-row">
          <div class="timeline-event">${gameTimeText} ${costBeforeText} ${eventName}</div>
          <div class="timeline-cost"><span class="remaining-cost">残りコスト：${remainingCostText}</span> ${overflowText}</div>
        </div>`;

        tr.appendChild(td(r.frame));
        tr.appendChild(td(r.time_sec.toFixed(3)));          // seconds view
        tr.appendChild(td(formatTime(remainingTime)));       // remaining time in mm:ss.fff format
        tr.appendChild(td(r.event_name || ''));              // event name
        tr.appendChild(td(r.active_recovery));
        tr.appendChild(td(r.cost_before.toFixed(2)));       // cost view before use
        tr.appendChild(td(r.cost_used));
        tr.appendChild(td(r.cost_after.toFixed(2)));        // cost view after use
        tbody.appendChild(tr);
      }
      
      timelineInfoEl.innerHTML = infoHTML;
    }

    // ==============================
    // Controls: cost_limit selector and SS toggle
    // ==============================
    
    // Cost limit controls
    const currentLimitEl = document.getElementById('currentLimit');
    const limitButtons = Array.from(document.querySelectorAll('.btn[data-limit]'));
    
    // Total time controls
    const currentTTEl = document.getElementById('currentTT');
    const ttButtons = Array.from(document.querySelectorAll('.btn[data-tt]'));
    
    // SS controls (for future implementation)
    const currentSSEl = document.getElementById('currentSS');
    const ssButtons = Array.from(document.querySelectorAll('.btn[data-ss]'));
    let ssEnabled = true; // デフォルトはオン

    function updateActiveButton() {
      // Update cost limit buttons
      limitButtons.forEach(btn => {
        const v = Number(btn.dataset.limit);
        btn.classList.toggle('active', v === cost_limit);
      });
      currentLimitEl.textContent = `(現在: ${cost_limit})`;
      
      // Update total time buttons
      ttButtons.forEach(btn => {
        const v = Number(btn.dataset.tt);
        btn.classList.toggle('active', v === totalTime);
      });
      currentTTEl.textContent = `(現在: ${totalTime}秒)`;
      
      // Update SS buttons
      ssButtons.forEach(btn => {
        const isOn = btn.dataset.ss === 'on';
        btn.classList.toggle('active', isOn === ssEnabled);
      });
      currentSSEl.textContent = `(現在: ${ssEnabled ? 'オン' : 'オフ'})`;
    }

    function recalcAndRender() {
      const rows = computeRows();
      renderTable(rows);
      updateActiveButton();
    }

    // Cost limit button event listeners
    limitButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        cost_limit = Number(btn.dataset.limit);
        costPointLimit = Math.round(cost_limit * COST_DENOM); // 変数を更新
        recalcAndRender();
      });
    });
    
    // Total time button event listeners
    ttButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        totalTime = Number(btn.dataset.tt);
        // processedInputが存在する場合はtotalTimeを更新し、タイムライン入力を再処理
        if (processedInput) {
          updateTimelineOutput();
        } else {
          recalcAndRender();
        }
      });
    });
    
    // SS button event listeners
    ssButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        ssEnabled = btn.dataset.ss === 'on';
        // processedInputが存在する場合はタイムライン入力を再処理
        if (processedInput) {
          updateTimelineOutput();
        } else {
          recalcAndRender();
        }
      });
    });

    // ==============================
    // Special character processing functionality
    // ==============================
    
    /**
     * イベント名処理と特殊キャラクター処理を行う関数
     * @param {string} rawEventName - 生のイベント名
     * @param {number} frame - イベントが発生するフレーム数
     * @returns {Array} costRecoveryBuff配列
     */
    function processEventName(rawEventName, frame) {
      // イベント名処理（EX削除）
      const processedEventName = rawEventName ? rawEventName.replace(/EX/g, '') : '';
      
      const costRecoveryBuff = [];
      
      // 水着ホシノ特例処理
      if (processedEventName && 
          ((processedEventName.includes('水着') && processedEventName.includes('ホシノ')) || 
           processedEventName.includes('水おじ'))) {
        costRecoveryBuff.push({
          buff_name: '水着ホシノEX',
          buff_start: frame + 21,
          buff_end: frame + 21 + (30 * 50),
          buff_amount: 684
        });
      }
      
      // 今後、他のキャラクターの特殊処理をここに追加
      // 例: アコ、ミカ、など
      
      return costRecoveryBuff;
    }

    // ==============================
    // Timeline input functionality
    // ==============================
    const timelineInput = document.getElementById('timelineInput');
    const timelineOutput = document.getElementById('timelineOutput');

    // 入力時にリアルタイムで更新
    function updateTimelineOutput() {
      // 1. 入力をパースして方向性を判定
      const inputEvents = parseTimelineToJSON(timelineInput.value);
      const direction = detectTimelineDirection(inputEvents);
      
      // 方向性に応じた時間表記の説明
      const timeNotation = direction === 'forward' 
        ? '時間表記: 経過時間での表記' 
        : '時間表記: ゲーム内時間表記（残り時間）';
      
      // 2. イベントリストを処理
      const convertedEvents = processEventsWithBuffHandling(inputEvents, direction);
      
      // 3. デフォルトイベントを追加
      const defaultEvents = [
        {
          frame: 0,
          student_num: 0,
          cost_used: 0,
          cost_recovery_buff_list: [],
          event_name: 'タイム計測開始'
        },
        {
          frame: 60,
          student_num: 6,
          cost_used: 0,
          cost_recovery_buff_list: [],
          event_name: '戦闘開始'
        }
      ];
      
      // 4. 最終的なイベント配列を作成
      const allEvents = [...defaultEvents, ...convertedEvents];
      
      // 5. フレーム順にソート
      allEvents.sort((a, b) => a.frame - b.frame);
      
      // 6. グローバル変数を更新
      processedInput = {
        direction: direction,
        totalTime: totalTime,
        events: allEvents
      };
      
      // 計算とレンダリングを再実行
      recalcAndRender();
      
      timelineOutput.textContent = timeNotation + '\n\n' + JSON.stringify(processedInput, null, 2);
    }
    
    /**
     * イベントリストをバフ処理と時間逆算を含めて処理する
     * @param {Array} inputEvents - 入力イベントリスト
     * @param {string} direction - 時間の方向性
     * @returns {Array} 処理済みイベントリスト
     */
    function processEventsWithBuffHandling(inputEvents, direction) {
      const result = [];
      let currentBuffs = [];
      
      for (const event of inputEvents) {
        // フレーム計算
        let frame;
        if (event.time !== null) {
          // 時間が指定されている場合
          if (direction === 'forward') {
            frame = Math.round(event.time * 30);
          } else {
            frame = Math.round((totalTime - event.time) * 30);
          }
        } else {
          // 時間がnullの場合、コストから逆算
          if (event.cost_before_use !== null) {
            frame = calculateFrameFromCost(event.cost_before_use, currentBuffs, result);
          } else {
            frame = 0; // フォールバック
          }
        }
        
        // バフ開始・終了イベントを挿入
        const { updatedResult, updatedBuffs } = insertBuffEvents(result, currentBuffs, frame);
        result.splice(0, result.length, ...updatedResult);
        currentBuffs = updatedBuffs;
        
        // 新しいバフを処理
        const newBuffs = processEventName(event.event_name, frame);
        currentBuffs = [...currentBuffs, ...newBuffs];
        
        // メインイベントを追加
        result.push({
          frame: frame,
          student_num: 6,
          cost_used: event.cost_used || 0,
          cost_recovery_buff_list: [...currentBuffs],
          event_name: event.event_name
        });
      }
      
      return result;
    }
    
    /**
     * 指定されたコストに達するフレームを逆算（再帰処理）
     * @param {number} targetCost - 目標コスト
     * @param {Array} currentBuffs - 現在のバフ状況
     * @param {Array} eventsSoFar - ここまでのイベントリスト
     * @returns {number} フレーム数
     */
    function calculateFrameFromCost(targetCost, currentBuffs, eventsSoFar) {
      // これまでのイベントから開始点を計算
      let startFrame = 60; // 戦闘開始フレーム
      let accumulatedCost = 0;
      
      if (eventsSoFar.length > 0) {
        // 最新のイベントの状況をシミュレート
        const simulation = simulateCostAtFrame(eventsSoFar);
        startFrame = simulation.lastFrame;
        accumulatedCost = simulation.costAtLastFrame;
      }
      
      return calculateFrameFromCostRecursive(targetCost, currentBuffs, eventsSoFar, startFrame, accumulatedCost);
    }
    
    /**
     * 指定されたイベントリストでのコスト状況をシミュレート
     * @param {Array} events - イベントリスト
     * @returns {Object} 最終フレームとそこでのコスト
     */
    function simulateCostAtFrame(events) {
      let cost_point = 0;
      let lastFrame = 60; // 戦闘開始
      
      // デフォルトイベントを含めてソート
      const allEvents = [
        { frame: 0, student_num: 0, cost_used: 0, cost_recovery_buff_list: [] },
        { frame: 60, student_num: 6, cost_used: 0, cost_recovery_buff_list: [] },
        ...events
      ].sort((a, b) => a.frame - b.frame);
      
      for (let i = 1; i < allEvents.length; i++) {
        const current = allEvents[i];
        const previous = allEvents[i - 1];
        
        const elapsed_frames = current.frame - previous.frame;
        const costRecovery = calculateCostRecoveryForEvent(previous);
        
        // コスト蓄積
        const cost_point_before_spill = cost_point + elapsed_frames * costRecovery;
        cost_point = Math.min(cost_point_before_spill, costPointLimit);
        
        // コスト使用
        const consume_points = Math.round((current.cost_used || 0) * COST_DENOM);
        cost_point = cost_point - consume_points;
        
        lastFrame = current.frame;
      }
      
      return {
        lastFrame: lastFrame,
        costAtLastFrame: cost_point / COST_DENOM
      };
    }
    
    /**
     * イベント用のコスト回復量計算（computeRowsと同じロジック）
     * @param {Object} event - イベントオブジェクト
     * @returns {number} フレーム当たりコスト回復量
     */
    function calculateCostRecoveryForEvent(event) {
      const base_recovery = 700;
      const cost_recovery_SS_buff = 0.2029;
      
      const unbuffed_students = event.student_num - event.cost_recovery_buff_list.length;
      let total_cost_recovery = 0;
      
      // バフのかかっていない生徒
      if (unbuffed_students > 0) {
        const unbuffed_actual = ssEnabled ? Math.round(base_recovery * (1 + cost_recovery_SS_buff)) : base_recovery;
        total_cost_recovery += unbuffed_students * unbuffed_actual;
      }
      
      // バフのかかっている生徒
      for (const buff of event.cost_recovery_buff_list) {
        const buffValue = typeof buff === 'object' ? buff.buff_amount : buff;
        const buffed_base = base_recovery + buffValue;
        const buffed_actual = ssEnabled ? Math.round(buffed_base * (1 + cost_recovery_SS_buff)) : buffed_base;
        total_cost_recovery += buffed_actual;
      }
      
      return total_cost_recovery;
    }
    
    /**
     * コストからフレーム逆算の再帰処理
     * @param {number} targetCost - 目標コスト
     * @param {Array} currentBuffs - 現在のバフ状況
     * @param {Array} eventsSoFar - ここまでのイベントリスト
     * @param {number} startFrame - 開始フレーム
     * @param {number} accumulatedCost - 累積コスト
     * @returns {number} フレーム数
     */
    function calculateFrameFromCostRecursive(targetCost, currentBuffs, eventsSoFar, startFrame, accumulatedCost) {
      // 現在のバフ状況でのコスト回復量を計算
      const activeBuffs = currentBuffs.filter(buff => 
        buff.buff_start <= startFrame && buff.buff_end > startFrame
      );
      
      // 次のバフイベント（開始または終了）を見つける
      const nextBuffEvent = findNextBuffEvent(currentBuffs, startFrame);
      
      if (nextBuffEvent === null) {
        // バフイベントがない場合、単純に計算
        const costRecovery = calculateCostRecoveryWithBuffs(activeBuffs);
        const remainingCost = (targetCost * COST_DENOM) - (accumulatedCost * COST_DENOM);
        
        if (remainingCost <= 0) {
          return startFrame; // 既に目標に達している
        }
        
        const framesNeeded = Math.ceil(remainingCost / costRecovery);
        return startFrame + framesNeeded;
      }
      
      // 次のバフイベントまでのコスト計算
      const framesToBuffEvent = nextBuffEvent.frame - startFrame;
      const costRecovery = calculateCostRecoveryWithBuffs(activeBuffs);
      const costAtBuffEvent = accumulatedCost + (framesToBuffEvent * costRecovery / COST_DENOM);
      
      if (costAtBuffEvent >= targetCost) {
        // 目標コストに達した場合
        const remainingCost = (targetCost * COST_DENOM) - (accumulatedCost * COST_DENOM);
        
        if (remainingCost <= 0) {
          return startFrame; // 既に目標に達している
        }
        
        const framesNeeded = Math.ceil(remainingCost / costRecovery);
        return startFrame + framesNeeded;
      }
      
      // 目標コストに達していない場合、バフイベント後の状況で再帰
      let newBuffs = [...currentBuffs];
      if (nextBuffEvent.type === 'end') {
        // バフ終了の場合、該当バフを削除
        newBuffs = newBuffs.filter(buff => 
          !(buff.buff_name === nextBuffEvent.buff.buff_name && 
            buff.buff_start === nextBuffEvent.buff.buff_start)
        );
      }
      
      return calculateFrameFromCostRecursive(
        targetCost, 
        newBuffs, 
        eventsSoFar, 
        nextBuffEvent.frame, 
        Math.min(costAtBuffEvent, costPointLimit / COST_DENOM) // コスト上限を適用
      );
    }
    
    /**
     * 指定されたバフでのコスト回復量を計算
     * @param {Array} activeBuffs - アクティブなバフリスト
     * @returns {number} フレーム当たりコスト回復量
     */
    function calculateCostRecoveryWithBuffs(activeBuffs) {
      const base_recovery = 700;
      const cost_recovery_SS_buff = 0.2029;
      
      const unbuffed_students = 6 - activeBuffs.length;
      let total_cost_recovery = 0;
      
      // バフのかかっていない生徒
      if (unbuffed_students > 0) {
        const unbuffed_actual = ssEnabled ? Math.round(base_recovery * (1 + cost_recovery_SS_buff)) : base_recovery;
        total_cost_recovery += unbuffed_students * unbuffed_actual;
      }
      
      // バフのかかっている生徒
      for (const buff of activeBuffs) {
        const buffValue = typeof buff === 'object' ? buff.buff_amount : buff;
        const buffed_base = base_recovery + buffValue;
        const buffed_actual = ssEnabled ? Math.round(buffed_base * (1 + cost_recovery_SS_buff)) : buffed_base;
        total_cost_recovery += buffed_actual;
      }
      
      return total_cost_recovery;
    }
    
    /**
     * 次のバフイベント（開始または終了）を見つける
     * @param {Array} buffs - バフリスト
     * @param {number} currentFrame - 現在のフレーム
     * @returns {Object|null} 次のバフイベント
     */
    function findNextBuffEvent(buffs, currentFrame) {
      let nextEvent = null;
      let minFrame = Infinity;
      
      for (const buff of buffs) {
        // バフ開始イベント
        if (buff.buff_start > currentFrame && buff.buff_start < minFrame) {
          nextEvent = { frame: buff.buff_start, type: 'start', buff };
          minFrame = buff.buff_start;
        }
        // バフ終了イベント
        if (buff.buff_end > currentFrame && buff.buff_end < minFrame) {
          nextEvent = { frame: buff.buff_end, type: 'end', buff };
          minFrame = buff.buff_end;
        }
      }
      
      return nextEvent;
    }
    

    
    /**
     * バフの開始・終了イベントを適切な位置に挿入
     * @param {Array} currentEvents - 現在のイベントリスト
     * @param {Array} currentBuffs - 現在のバフ状況
     * @param {number} targetFrame - 目標フレーム
     * @returns {Object} 更新されたイベントリストとバフ状況
     */
    function insertBuffEvents(currentEvents, currentBuffs, targetFrame) {
      const result = [...currentEvents];
      let updatedBuffs = [...currentBuffs];
      const previousFrame = result.length > 0 ? result[result.length - 1].frame : 0;
      
      const buffsToRemove = [];
      
      for (const buff of currentBuffs) {
        // バフ開始イベントの挿入
        if (buff.buff_start > previousFrame && buff.buff_start <= targetFrame) {
          result.push({
            frame: buff.buff_start,
            student_num: 6,
            cost_used: 0,
            cost_recovery_buff_list: [buff],
            event_name: `${buff.buff_name}開始`
          });
        }
        
        // バフ終了イベントの挿入
        if (buff.buff_end > previousFrame && buff.buff_end <= targetFrame) {
          buffsToRemove.push(buff);
          
          // 同名バフの重複チェック
          const sameNameBuff = currentBuffs.find(otherBuff => 
            otherBuff !== buff && 
            otherBuff.buff_name === buff.buff_name &&
            buff.buff_end >= otherBuff.buff_start &&
            buff.buff_end < otherBuff.buff_end
          );
          
          if (!sameNameBuff) {
            result.push({
              frame: buff.buff_end,
              student_num: 6,
              cost_used: 0,
              cost_recovery_buff_list: [],
              event_name: `${buff.buff_name}終了`
            });
          }
        }
      }
      
      // 終了したバフを削除
      updatedBuffs = updatedBuffs.filter(buff => !buffsToRemove.includes(buff));
      
      return { updatedResult: result, updatedBuffs };
    }

    timelineInput.addEventListener('input', updateTimelineOutput);

    // Initial paint
    recalcAndRender();
    // 初期テキストも正規化して表示
    updateTimelineOutput();
  </script>
</body>
</html>
