<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Blue Archive – TL Assistant</title>
  <script src="utilities.js" onload="console.log('utilities.js loaded')" onerror="console.error('utilities.js failed to load')"></script>
  <script src="buffs.js" onload="console.log('buffs.js loaded')" onerror="console.error('buffs.js failed to load')"></script>
  <script src="radiator-manager.js" onload="console.log('radiator-manager.js loaded')" onerror="console.error('radiator-manager.js failed to load')"></script>
  <script src="input-processor.js?v=5&timestamp=1736702000000" onload="console.log('input-processor.js loaded')" onerror="console.error('input-processor.js failed to load')"></script>
  <script src="tl-editor.js" onload="console.log('tl-editor.js loaded')" onerror="console.error('tl-editor.js failed to load')"></script>
  <script src="timeline-formatter.js" onload="console.log('timeline-formatter.js loaded')" onerror="console.error('timeline-formatter.js failed to load')"></script>
  <style>
    body { 
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP", sans-serif; 
      margin: 0; 
      padding: 24px; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      overflow: hidden;
    }
    
    .header {
      background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
      color: white;
      padding: 24px;
      text-align: center;
    }
    
    h1 { 
      font-size: 2rem; 
      margin: 0 0 8px; 
      font-weight: 700;
    }
    
    .subtitle {
      font-size: 1.1rem;
      opacity: 0.9;
      margin: 0;
    }
    
    .main-content {
      padding: 24px;
    }
    
    .controls { 
      display: flex; 
      gap: 12px; 
      flex-wrap: wrap; 
      align-items: center; 
      <!-- 縦幅の調整はmarginとpaddingを調節することで行います -->
      margin: 2px 0; 
      padding: 4px;
      background: #f8fafc;
      border-radius: 12px;
    }
    
    .btn { 
      padding: 4px 8px; 
      border-radius: 8px; 
      border: 2px solid transparent; 
      background: #4f46e5; 
      color: white;
      cursor: pointer; 
      font-weight: 500;
      transition: all 0.2s ease;
    }
    
    .btn:hover { 
      background: #4338ca; 
      transform: translateY(-1px);
    }
    
    .btn.active { 
      background: #10b981; 
      border-color: #059669; 
    }
    
    .btn.secondary {
      background: #6b7280;
      color: white;
    }
    
    .btn.secondary:hover {
      background: #4b5563;
    }

    /* カノエ・チェリノボタン用の小さなスタイル */
    .btn.small {
      padding: 4px 4px;
      font-size: 0.8rem;
      min-width: auto;
      margin: 1px 2px;
    }

    /* カノエ・チェリノのコントロール行のスペースを小さく */
    .controls.compact {
      gap: 0px;
      margin: 0px 0;
      padding: 0px;
    }
    
    /* 設定パネル */
    .settings-panel {
      background: #f1f5f9;
      border-radius: 12px;
      padding: 20px;
      margin: 16px 0;
      border: 2px solid #e2e8f0;
    }
    
    /* 設定項目の解説文 */
    .setting-comment {
      margin-left: 10px;
      color: #6b7280;
      font-size: 0.9rem;
      margin-top: 4px;
      margin-bottom: 12px;
    }
    
    /* 基本設定の2列レイアウト */
    .settings-basic {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }
    
    @media (min-width: 768px) {
      .settings-basic {
        grid-template-columns: 1fr 1fr;
        gap: 16px;
      }
    }
    
    .settings-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
    }
    
    .form-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .form-group label {
      font-weight: 600;
      color: #374151;
      font-size: 0.9rem;
    }
    
    .form-group input, .form-group select {
      padding: 8px 12px;
      border: 2px solid #d1d5db;
      border-radius: 6px;
      font-size: 0.9rem;
    }
    
    .form-group input:focus, .form-group select:focus {
      outline: none;
      border-color: #4f46e5;
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
    }
    
    /* タイムライン表示 */
    .timeline-container { 
      display: flex; 
      flex-direction: column; 
      gap: 20px; 
    }
    
    @media (min-width: 900px) {
      .timeline-container { 
        flex-direction: row; 
      }
      .timeline-input-section { 
        flex: 0.45; 
      }
      .timeline-output-section { 
        flex: 0.55; 
      }
    }
    
    .input-section, .output-section {
      background: #f8fafc;
      border-radius: 12px;
      padding: 20px;
      border: 2px solid #e2e8f0;
    }
    
    .section-title {
      font-size: 1.2rem;
      font-weight: 600;
      color: #1f2937;
      margin: 0 0 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    textarea {
      width: 96.5%;
      height: 300px;
      padding: 12px;
      border: 2px solid #d1d5db;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
      resize: vertical;
    }
    
    textarea:focus {
      outline: none;
      border-color: #4f46e5;
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
    }
    
    table { 
      border-collapse: collapse; 
      width: 100%; 
      margin: 16px 0;
      background: white;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    /* レスポンシブ対応：ヘッダーのみフォントサイズ調整 */
    @media (max-width: 1200px) {
      thead th {
        font-size: 0.65rem;
      }
    }
    
    @media (max-width: 900px) {
      thead th {
        font-size: 0.6rem;
      }
    }
    
    @media (max-width: 600px) {
      thead th {
        font-size: 0.55rem;
      }
    }
    
    thead th { 
      position: sticky; 
      top: 0; 
      background: #4f46e5; 
      color: white;
      font-weight: 600;
      font-size: 0.7rem; /* ヘッダー行のフォントサイズをさらに小さく */
    }
    
    th, td { 
      border: 1px solid #e5e7eb; 
      padding: 10px 12px; /* 元のサイズに戻す */
      font-variant-numeric: tabular-nums; 
      text-align: right; 
    }
    
    th:first-child, td:first-child, 
    th:nth-child(2), td:nth-child(2), 
    th:nth-child(3), td:nth-child(3), 
    th:nth-child(4), td:nth-child(4),
    th:nth-child(6), td:nth-child(6) { 
      text-align: center; 
    }
    
    tbody tr:nth-child(even) {
      background: #f9fafb;
    }
    
    tbody tr:hover {
      background: #f3f4f6;
    }
    
    .cost-overflow { 
      color: #dc2626; 
      font-weight: bold; 
      background: #fef2f2;
      padding: 2px 6px;
      border-radius: 4px;
    }
    
    .cost-normal {
      color: #059669;
    }
    
    .remaining-cost { 
      color: #059669; 
      font-weight: bold; 
    }
    
    .muted { 
      color: #6b7280; 
      font-size: 0.9rem; 
    }
    
    .summary { 
      margin: 16px 0; 
      padding: 16px;
      background: white;
      border-radius: 8px;
      border-left: 4px solid #4f46e5;
    }
    
    .error-message {
      background: #fef2f2;
      color: #dc2626;
      padding: 12px 16px;
      border-radius: 8px;
      border: 1px solid #fecaca;
      margin: 16px 0;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
      position: relative;
    }
    
    .success-message {
      background: #f0fdf4;
      color: #166534;
      padding: 12px 16px;
      border-radius: 8px;
      border: 1px solid #bbf7d0;
      margin: 16px 0;
    }
    
    .info-message {
      background: #eff6ff;
      color: #1d4ed8;
      padding: 12px 16px;
      border-radius: 8px;
      border: 1px solid #bfdbfe;
      margin: 16px 0;
    }
    
    /* JSON出力エリア */
    .json-output {
      background: #1f2937;
      color: #f9fafb;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      padding: 16px;
      border-radius: 8px;
      white-space: pre-wrap;
      max-height: 400px;
      overflow-y: auto;
      border: 2px solid #374151;
    }
    
    /* アコーディオン */
    .accordion {
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      margin: 16px 0;
      overflow: hidden;
    }
    
    .accordion-header {
      background: #f3f4f6;
      padding: 12px 16px;
      cursor: pointer;
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .accordion-header:hover {
      background: #e5e7eb;
    }
    
    .accordion-content {
      padding: 16px;
      background: white;
      display: none;
    }
    
    .accordion.open .accordion-content {
      display: block;
    }
    
    .accordion.open .accordion-toggle::after {
      content: "−";
    }
    
    .accordion-toggle::after {
      content: "＋";
      font-weight: bold;
    }

    /* タイムライン表示用スタイル */
    .timeline-display {
      background: #fff8e1;
      border: 1px solid #ffc947;
      border-radius: 8px;
      padding: 16px;
      margin: 16px 0;
      line-height: 1.6;
    }

    .timeline-row {
      display: flex;
      margin-bottom: 8px;
      padding: 4px 0;
      border-bottom: 1px solid #f0f0f0;
    }

    .timeline-row:last-child {
      border-bottom: none;
    }

    .timeline-event {
      flex: 0 0 300px;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
    }

    .timeline-cost {
      flex: 1;
      padding-left: 16px;
      font-size: 0.85rem;
    }

    .remaining-cost {
      color: #1976d2;
      font-weight: bold;
    }

    .cost-overflow {
      color: #d32f2f;
      font-weight: bold;
    }
    
    /* セーブスロット用スタイル */
    .save-slot-section {
      background: #f8fafc;
      border-radius: 12px;
      padding: 12px; /* 16px から 12px に縮小 */
      margin: 0px 0; /* 16px から 8px に縮小 */
      border: 2px solid #e2e8f0;
    }
    
    .save-slot-item {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      gap: 8px;
      min-width: 240px;
      max-width: 400px; /* 300pxから400pxに拡大 */
      flex: 1 1 280px; /* 250pxから280pxに拡大 */
      margin-bottom: 0px; /* スロット間の間隔 */
    }
    
    /* スロット4以降用の小さいスタイル */
    .save-slot-item.compact {
      min-width: 240px;
      max-width: 400px; /* 320pxから400pxに拡大 */
      flex: 1 1 240px;
    }
    
    .save-slot-item.compact .save-slot-preview {
      font-size: 10px; /* 11px から 10px に縮小 */
    }
    
    .save-slot-buttons {
      display: flex;
      flex-direction: row; /* 横並びに変更 */
      gap: 4px; /* ボタン間の間隔を小さく */
      flex-shrink: 0;
    }
    
    .save-slot-buttons .btn {
      font-size: 12px;
      padding: 3px 4px;
      min-width: 50px;
    }
    
    .save-slot-preview {
      color: #6b7280;
      font-size: 11px;
      font-weight: bold;
      line-height: 1.3;
      word-break: break-all;
      overflow: hidden;
      white-space: pre-line; /* 改行を保持 */
      max-height: 2.6em; /* 約2行分の高さ */
      text-overflow: ellipsis;
      min-height: auto;
      width: 70% !important;
      flex-shrink: 0;
      padding: 2px 4px;
      align-self: center;
    }
    
    .save-slot-preview.has-data {
      color: #374151;
    }
    
    /* レスポンシブ対応 */
    @media (max-width: 768px) {
      .save-slot-section > div {
        flex-direction: column;
        align-items: stretch;
      }
      
      .save-slot-item {
        min-width: auto;
        max-width: none;
        flex: 1 1 auto;
        margin-bottom: 8px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>ブルーアーカイブ TL Assistant</h1>
      <p class="subtitle">【超重要】未完成 - おかしいことあったら教えてください！！</p>
    </div>
    
    <div class="main-content">
      <!-- 設定パネル -->
      <div class="settings-panel">
        <h3 class="section-title">⚙️ 設定</h3>
        
        <!-- 基本設定 -->
        <div class="settings-basic">
          <div class="controls">
            <span>戦闘時間：</span>
            <button class="btn" data-tt="180">180秒</button>
            <button class="btn" data-tt="240">240秒</button>
            <span id="currentTT" class="muted"></span>
          </div>

          <div class="controls">
            <span>コスト回復量増加SS：</span>
            <button class="btn" data-ss="on">オン</button>
            <button class="btn" data-ss="off">オフ</button>
            <span id="currentSS" class="muted"></span>
          </div>
          
          <div class="controls">
            <span>最大コスト：</span>
            <button class="btn" data-limit="10">10</button>
            <button class="btn" data-limit="10.5">10.5</button>
            <button class="btn" data-limit="11">11</button>
            <span id="currentLimit" class="muted"></span>
          </div>

          <div class="controls">
            <span>セイア固有2：</span>
            <button class="btn" data-seia="yes">あり</button>
            <button class="btn" data-seia="no">なし</button>
            <span id="currentSeia" class="muted"></span>
          </div>

          <div class="controls compact">
            <span>カノエ：</span>
            <button class="btn small" data-kanoe="0">なし</button>
            <button class="btn small" data-kanoe="1">本人のみ</button>
            <button class="btn small" data-kanoe="2">本人+1</button>
            <button class="btn small" data-kanoe="3">本人+2</button>
            <button class="btn small" data-kanoe="4">本人+3</button>
            <span id="currentKanoe" class="muted"></span>
          </div>

          <div class="controls compact">
            <span>チェリノ：</span>
            <button class="btn small" data-cherino="0">なし</button>
            <button class="btn small" data-cherino="1">本人のみ</button>
            <button class="btn small" data-cherino="2">本人+1</button>
            <button class="btn small" data-cherino="3">本人+2</button>
            <button class="btn small" data-cherino="4">本人+3</button>
            <span id="currentCherino" class="muted"></span>
          </div>
        </div>

        <!-- 詳細設定（アコーディオン） -->
        <div class="accordion">
          <div class="accordion-header" onclick="toggleAccordion(this)">
            🔧 詳細設定
            <span class="accordion-toggle"></span>
          </div>
          <div class="accordion-content">
            <div class="controls">
              <span>「：」のない行頭数字の解釈：</span>
              <button class="btn" data-number="time">タイム</button>
              <button class="btn" data-number="cost">コストタイミング</button>
              <span id="currentNumber" class="muted"></span>
            </div>
            <div class="setting-comment">
              例えば「8.2 キャンプハレ」の場合、8.2コストでハレなのか、開始8.2秒後にハレなのかを設定します。
            </div>

            <div class="controls">
              <span>時間表示形式：</span>
              <button class="btn" data-display="backward">ゲーム内表示</button>
              <button class="btn" data-display="forward">経過時間</button>
              <span id="currentDisplay" class="muted"></span>
            </div>
            <div class="setting-comment">
              20.000あるいは00:20.000を、ゲーム内表示（残り時間）形式と解釈するか、経過した時間と解釈するかを設定します。
            </div>

            <div class="controls">
              <span>+/-の解釈：</span>
              <button class="btn" data-modifier="yes">常に秒後/秒前</button>
              <button class="btn" data-modifier="no">表示形式に依存</button>
              <span id="currentModifier" class="muted"></span>
            </div>
            <div class="setting-comment">
              +/-を常に〇秒後/秒前と解釈するか、あるいは逆として解釈するか（ゲーム内表示の場合のみ）を設定します。
            </div>

            <div class="controls">
              <span>特殊コマンドを受け付ける：</span>
              <button class="btn" data-special="yes">はい</button>
              <button class="btn" data-special="no">いいえ</button>
              <span id="currentSpecial" class="muted"></span>
            </div>
            <div class="setting-comment">
              「コスト回復力」と書いてある場合その行をコスト回復力変更イベントとみなします。
            </div>
          </div>
        </div>
      </div>

      <!-- 記入方法 -->
      <div class="accordion">
        <div class="accordion-header" onclick="toggleAccordion(this)">
          📖 記入方法
          <span class="accordion-toggle"></span>
        </div>
        <div class="accordion-content">
          サンプルを見れば大体わかると思うので、まずサンプルを見てください。<br>
          わからなければ以下の説明を参考にし、それでもだめなら<a href="https://x.com/atsubakutaro">ぼく</a>に直接聞いてください。
          <h4>許される記法</h4>
          <ul>
            <li>2:43 [10] ミカ [6] - 2:43.000のタイミングでミカが6コスト消費、コストタイミング指定[10]は無視される。[ ]は省略可能</li>
            <li>[9.8] セイア [3] - 9.8コスト溜まる最も早いタイミングでセイアが3コスト消費</li>
            <li>イブキ [3] - [3]イブキ[3]と同じ。3コストでイブキが3コスト消費</li>
            <li>[-2]Ｃ水着ミカ[3] - コスト-2のタイミングでＣ水着ミカが3コスト消費。水着ナギサ実装により、このようなマイナス記法も許される</li>
          </ul>
            
          <h4>詳細</h4>
          <ul>
            <li><strong>表記ゆれ</strong>: 空白、[ ]の有無、全角半角などの表記ゆれは可能な限り許すように設計されているので基本心配不要</li>
            <li><strong>行の基本構造</strong>: （何らかの時間指定）（イベント名）（コスト消費）（ラベル設定）の構造、一部省略可能</li>
            <li><strong>ラベル設定</strong>: 特定のタイミングに「#ミカ1」のようにラベルを設定し、その時間を起点に別の行動の時間を指定可能。「ラベル参照」を見ること</li>
            <li><strong>ラベル参照</strong>: 行頭に「#ミカ1 +3.433」でラベルから3.433秒後、「#ミカ1 -2.167」で2.167秒前（設定で+/-の解釈反転可能）</li>
            <li><strong>省略した場合の処理</strong>: 
              <ul>
                <li>消費コスト指定がない場合: 0コスで実行できるイベントと判断</li>
                <li>時間・コストタイミング指定がない場合: 消費コストが溜まる最速のフレームでスキルを実行</li>
              </ul>
            </li>
            <li><strong>コメントアウト</strong>: 行頭に！（全角，半角可）をつけた行は無視されるのでコメントとして使用できる</li>
          </ul>

          <h4>コスト回復バフ対応</h4>
          <ul>
            <li>以下の名前を含んでいると自動的にコスト回復力上昇バフが追加されます：</li>
            <ul>
              <li><strong>水着ホシノ</strong>:「水」と（「ホシノ」あるいは「おじ」）を含んでいる場合</li>
              <ul>
                <li>水着ホシノのコスト回復着弾タイムは手動の場合0.833秒、AUTOの場合0.800秒です。本ツールの設計思想としてすべて手動のタイムに合わせます。AUTO指定の場合は0.033秒前の時間を指定してください。（いずれAUTO機能も実装予定）</li>
              </ul>
              <li><strong>セイア</strong>: 「セイア」を含むが「水」を含まない場合</li>
            </ul>
          </ul>
        </div>
      </div>

      <!-- 操作ボタン -->
      <div class="controls">
        <button class="btn" onclick="triggerAutoUpdate()">🚀 タイムライン生成</button>
        <button class="btn secondary" onclick="clearAll()">🗑️ クリア</button>
        <button class="btn" id="autoUpdateToggle" onclick="toggleAutoUpdate()">🔄 自動更新: ON</button>
      </div>
      
      <!-- セーブ/ロードボタン -->
      <div class="save-slot-section" style="margin-top: 5px;">
        <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: flex-start;">
          <span style="font-weight: bold; margin-right: 10px; line-height: 32px;">💾 セーブスロット:</span>
          
          <!-- 基本セーブスロット（1-2） -->
          <div class="save-slot-item" data-slot="1">
            <div class="save-slot-buttons">
              <button class="btn secondary save-btn" onclick="saveToSlot(1)">保存1</button>
              <button class="btn secondary load-btn" onclick="loadFromSlot(1)">読込1</button>
            </div>
            <div class="save-slot-preview" id="slot-preview-1">（空のデータスロット）</div>
          </div>
          
          <div class="save-slot-item" data-slot="2">
            <div class="save-slot-buttons">
              <button class="btn secondary save-btn" onclick="saveToSlot(2)">保存2</button>
              <button class="btn secondary load-btn" onclick="loadFromSlot(2)">読込2</button>
            </div>
            <div class="save-slot-preview" id="slot-preview-2">（空のデータスロット）</div>
          </div>
          <!-- 改行用の見えない要素 -->
          <div style="width: 100%; height: 0; flex-basis: 100%;"></div>
        </div>
        
        <!-- 追加セーブスロット（3-10）アコーディオン -->
        <div class="accordion" style="margin-top: 10px;">
          <div class="accordion-header" onclick="toggleAccordion(this)">
            📁 追加セーブスロット
            <span class="accordion-toggle"></span>
          </div>
          <div class="accordion-content">
            <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: flex-start;">
              <div class="save-slot-item compact" data-slot="3">
                <div class="save-slot-buttons">
                  <button class="btn secondary save-btn" onclick="saveToSlot(3)">保存3</button>
                  <button class="btn secondary load-btn" onclick="loadFromSlot(3)">読込3</button>
                </div>
                <div class="save-slot-preview" id="slot-preview-3">（空のデータスロット）</div>
              </div>
              
              <div class="save-slot-item compact" data-slot="4">
                <div class="save-slot-buttons">
                  <button class="btn secondary save-btn" onclick="saveToSlot(4)">保存4</button>
                  <button class="btn secondary load-btn" onclick="loadFromSlot(4)">読込4</button>
                </div>
                <div class="save-slot-preview" id="slot-preview-4">（空のデータスロット）</div>
              </div>
              <!-- 改行用の見えない要素 -->
              <div style="width: 100%; height: 0; flex-basis: 100%;"></div>
              
              <div class="save-slot-item compact" data-slot="5">
                <div class="save-slot-buttons">
                  <button class="btn secondary save-btn" onclick="saveToSlot(5)">保存5</button>
                  <button class="btn secondary load-btn" onclick="loadFromSlot(5)">読込5</button>
                </div>
                <div class="save-slot-preview" id="slot-preview-5">（空のデータスロット）</div>
              </div>
              
              <div class="save-slot-item compact" data-slot="6">
                <div class="save-slot-buttons">
                  <button class="btn secondary save-btn" onclick="saveToSlot(6)">保存6</button>
                  <button class="btn secondary load-btn" onclick="loadFromSlot(6)">読込6</button>
                </div>
                <div class="save-slot-preview" id="slot-preview-6">（空のデータスロット）</div>
              </div>
              <!-- 改行用の見えない要素 -->
              <div style="width: 100%; height: 0; flex-basis: 100%;"></div>
              
              <div class="save-slot-item compact" data-slot="7">
                <div class="save-slot-buttons">
                  <button class="btn secondary save-btn" onclick="saveToSlot(7)">保存7</button>
                  <button class="btn secondary load-btn" onclick="loadFromSlot(7)">読込7</button>
                </div>
                <div class="save-slot-preview" id="slot-preview-7">（空のデータスロット）</div>
              </div>
              
              <div class="save-slot-item compact" data-slot="8">
                <div class="save-slot-buttons">
                  <button class="btn secondary save-btn" onclick="saveToSlot(8)">保存8</button>
                  <button class="btn secondary load-btn" onclick="loadFromSlot(8)">読込8</button>
                </div>
                <div class="save-slot-preview" id="slot-preview-8">（空のデータスロット）</div>
              </div>
              <!-- 改行用の見えない要素 -->
              <div style="width: 100%; height: 0; flex-basis: 100%;"></div>
              
              <div class="save-slot-item compact" data-slot="9">
                <div class="save-slot-buttons">
                  <button class="btn secondary save-btn" onclick="saveToSlot(9)">保存9</button>
                  <button class="btn secondary load-btn" onclick="loadFromSlot(9)">読込9</button>
                </div>
                <div class="save-slot-preview" id="slot-preview-9">（空のデータスロット）</div>
              </div>
              
              <div class="save-slot-item compact" data-slot="10">
                <div class="save-slot-buttons">
                  <button class="btn secondary save-btn" onclick="saveToSlot(10)">保存10</button>
                  <button class="btn secondary load-btn" onclick="loadFromSlot(10)">読込10</button>
                </div>
                <div class="save-slot-preview" id="slot-preview-10">（空のデータスロット）</div>
              </div>
              <!-- 改行用の見えない要素 -->
              <div style="width: 100%; height: 0; flex-basis: 100%;"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- メイン作業エリア -->
      <div class="timeline-container">
        <!-- 入力セクション -->
        <div class="timeline-input-section">
          <div class="input-section">
            <h3 class="section-title">📝 タイムライン入力</h3>
            <textarea id="timelineInput" placeholder="例:
！行頭に「！」を書くとコメント行になり無視されます
!全角でも半角でもいいですが、絵文字はダメです❗
！このサンプルを試したい場合はサンプル6を押してください
[5.0]水着ナギサ[3]
[6]ハレ[2] 上振れてSSで輝ペロロ倒すとリスタ
[8.5]カノエ[3]
[9.9]カヨコ[2]
[9.9]臨戦[6]
03:22 キサキ[3]
03:18.433 ナギサ[3]
03:14 ハレ[2] 
3:08.5 臨戦[6]
[2]カヨコ[2]
[7]ナギサ[3]
[5]ハレ[2]
[8.8]右端輝きペロロが振り返る直前臨戦[6]
キサキ[3]
[4]カヨコ歩きはじめたら、足止めカヨコEX[2]
カノエ[3]
[4]NS後ハレ[2]
[3]ナギサ[3]
[9.9]臨戦[6]
キサキ[3]
カヨコ[2]
01:53.900 ハレ[2]
[1]臨戦[6]"></textarea>
            
            <!-- サンプルタイムライン -->
            <div style="margin-top: 16px;">
              <div style="display: flex; gap: 15px; flex-wrap: wrap; align-items: flex-start;">
                <span style="font-weight: bold; margin-right: 10px; line-height: 32px;">サンプル:</span>
                <button class="btn secondary" onclick="loadSampleTimeline(1)" style="font-size: 12px; padding: 4px 8px;">1</button>
                <button class="btn secondary" onclick="loadSampleTimeline(2)" style="font-size: 12px; padding: 4px 8px;">2</button>
                <button class="btn secondary" onclick="loadSampleTimeline(3)" style="font-size: 12px; padding: 4px 8px;">3</button>
                <button class="btn secondary" onclick="loadSampleTimeline(4)" style="font-size: 12px; padding: 4px 8px;">4</button>
                <button class="btn secondary" onclick="loadSampleTimeline(5)" style="font-size: 12px; padding: 4px 8px;">5</button>
                <button class="btn secondary" onclick="loadSampleTimeline(6)" style="font-size: 12px; padding: 4px 8px;">6</button>
                <button class="btn secondary" onclick="loadSampleTimeline(7)" style="font-size: 12px; padding: 4px 8px;">7</button>
                <button class="btn secondary" onclick="loadSampleTimeline(8)" style="font-size: 12px; padding: 4px 8px;">8</button>
              </div>
            </div>
          </div>
        </div>

        <!-- 出力セクション -->
        <div class="timeline-output-section">
          <div class="output-section">
            <h3 class="section-title">� タイムライン出力</h3>
            
            <!-- タイムライン表示セクション -->
            <div class="section" id="timelineSection" style="display: none;">
              <!-- タイムライン表示 -->
              <div id="timelineDisplay" class="timeline-display"></div>
              
              <!-- テキスト出力アコーディオン -->
              <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                  📄 テキスト形式タイムライン
                  <span class="accordion-toggle"></span>
                </div>
                <div class="accordion-content">
                  <textarea id="timelineTextOutput" readonly style="height: 200px; font-family: 'Courier New', monospace; background: #f9f9f9;"></textarea>
                  <button class="btn secondary" onclick="copyTimelineText()" style="margin-top: 8px;">📋 コピー</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- タイムライン結果セクション -->
      <div class="section" id="timelineResultsSection">
        <div class="output-section">
          <h3 class="section-title">詳細情報</h3>
          <div id="timelineOutput">
            <!-- JavaScript で空のテーブルが挿入されます -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // =============================================================================
    // 🌐 グローバル変数（設定・状態管理）
    // =============================================================================
    
    // アプリケーション状態管理
    let currentTimelineJSON = null;  // 現在処理中のタイムラインJSONデータ
    let currentInputJSON = null;     // 現在の入力データのJSON表現
    let autoUpdateTimer = null;      // 自動更新用のタイマーID
    let autoUpdateEnabled = true;    // 自動更新機能の有効/無効フラグ
    
    // バフデータをグローバルに保存
    let buffData = window.BUFF_DATA || null;  // バフ効果データの参照
    
    // アプリケーション設定値（グローバル設定オブジェクト）
    const settings = {
      battle_time: 180,                     // 戦闘時間（秒）
      ss_enabled: true,                     // SS有効フラグ
      max_cost: 10,                        // 最大コスト設定
      number_interpretation: 'cost',        // 行頭数字の解釈方法
      time_display_format: 'backward',      // 時間表示形式（backward/forward）
      modifier_always_forward: 'yes',       // +/-の解釈方向
      seia_koyuu2: 'yes',                  // セイア固有2の有無（デフォルト：あり）
      kanoe_ss: '0',                       // カノエのレベル（デフォルト：なし）
      cherino_ss: '0',                     // チェリノのレベル（デフォルト：なし）
      special_command_accepted: 'yes'      // 特殊コマンドを受け付ける（デフォルト：はい）
    };

    // タイムラインに関連する設定項目のキー一覧
    // これらの設定はセーブスロットのセーブデータに含まれ、スロットからロードする際に復元される
    const timeline_related_setting_keys = [
      'battletime',
      'ss_enabled', 
      'max_cost',
      'seia_koyuu2',
      'kanoe_ss',
      'cherino_ss',
      'number_interpretation',
      'time_display_format',
      'modifier_always_forward',
      'special_command_accepted'
    ];

    /**
     * updateSlotPreview - スロットのプレビューテキストを更新
     * @param {number} slotNumber - 更新するスロット番号（1-10）
     * LocalStorageからデータを読み込み、プレビューテキストを表示する
     */
    function updateSlotPreview(slotNumber) {
      const previewElement = document.getElementById(`slot-preview-${slotNumber}`);
      if (!previewElement) return;
      
      const savedDataStr = localStorage.getItem(`tl-assistant-slot-${slotNumber}`);
      
      if (!savedDataStr) {
        // データがない場合
        previewElement.innerHTML = '（空のデータスロット）';
        previewElement.classList.remove('has-data');
      } else {
        try {
          const saveData = JSON.parse(savedDataStr);
          // データの最初の2行を取得（コメント行も含む）
          const lines = saveData.data.split('\n').map(line => line.trim()).filter(line => line);
          const previewLines = lines.slice(0, 2); // 最初の2行を取得
          const previewText = previewLines.length > 0 ? previewLines.join('<br>') : saveData.data.substring(0, 50);
          
          previewElement.innerHTML = previewText;
          previewElement.classList.add('has-data');
        } catch (error) {
          previewElement.innerHTML = '（データ読み込みエラー）';
          previewElement.classList.remove('has-data');
        }
      }
    }

    /**
     * updateAllSlotPreviews - 全スロットのプレビューを更新
     * アプリケーション起動時や必要に応じて全スロットのプレビューを一括更新
     */
    function updateAllSlotPreviews() {
      for (let i = 1; i <= 10; i++) {
        updateSlotPreview(i);
      }
    }
    


    /**
     * applyLoadedSettings - 読み込まれた設定を現在の設定に安全に適用
     * @param {Object} loaded_settings - 読み込まれた設定オブジェクト（一部のキーが未定義の可能性がある）
     * 
     * loaded_settingsは基本的にsettingsと同じ構造を持つが、いくつかのキーが
     * nullや未定義の場合がある。定義されている部分のみ現在の設定を上書きする。
     * 後方互換性のため、TLセーブデータにsettingsキーが含まれていない場合でも
     * 安全に処理できるように設計されている。
     */
    function applyLoadedSettings(loaded_settings) {
      if (!loaded_settings || typeof loaded_settings !== 'object') {
        console.log('設定データが無効または存在しません');
        return;
      }

      // 定義されているキーのみを現在の設定に適用
      for (const key in loaded_settings) {
        if (loaded_settings.hasOwnProperty(key) && 
            settings.hasOwnProperty(key) && 
            loaded_settings[key] !== null && 
            loaded_settings[key] !== undefined) {
          settings[key] = loaded_settings[key];
        }
      }

      console.log('設定を適用しました:', settings);
    }
    
    /**
     * saveSettings - アプリケーション設定をlocalStorageに保存
     * グローバル設定オブジェクトの内容を永続化する
     */
    function saveSettings() {
      localStorage.setItem('tl-assistant-settings', JSON.stringify(settings));
    }

    /**
     * loadSettings - localStorageからアプリケーション設定を復元
     * 保存された設定値を読み込み、グローバル設定オブジェクトに適用する
     * エラー時は警告を出力し、デフォルト値を維持する
     */
    function loadSettings() {
      try {
        const savedSettingsStr = localStorage.getItem('tl-assistant-settings');
        if (savedSettingsStr) {
          const savedSettings = JSON.parse(savedSettingsStr);
          
          // 古い形式の設定データをマイグレーション
          if (savedSettings.battleTime !== undefined) {
            // 旧形式からの変換
            settings.battle_time = savedSettings.battleTime || settings.battle_time;
            settings.ss_enabled = savedSettings.ssEnabled !== undefined ? savedSettings.ssEnabled : settings.ss_enabled;
            settings.max_cost = savedSettings.maxCost || settings.max_cost;
            settings.number_interpretation = savedSettings.numberInterpretation || settings.number_interpretation;
            settings.time_display_format = savedSettings.timeDisplayFormat || settings.time_display_format;
            settings.modifier_always_forward = savedSettings.modifierAlwaysForward || settings.modifier_always_forward;
            settings.seia_koyuu2 = savedSettings.seiaKoyuu2 || settings.seia_koyuu2;
            settings.kanoe_ss = savedSettings.kanoeSS || settings.kanoe_ss;
            settings.cherino_ss = savedSettings.cherinoSS || settings.cherino_ss;
          } else {
            // 新形式の設定データを直接適用
            Object.assign(settings, savedSettings);
          }
          
          console.log('設定を復元しました:', settings);
        }
      } catch (error) {
        console.warn('設定の復元に失敗しました:', error);
      }
    }

    /**
     * saveToSlot - タイムラインデータをスロット別にlocalStorageに保存
     * @param {number} slotNumber - 保存先スロット番号（1-10）
     * 既存データがある場合は上書き確認を行う
     * データ形式: {data: string, settings: object, timestamp: string, preview: string}
     */
    function saveToSlot(slotNumber) {
      const inputText = document.getElementById('timelineInput').value;
      if (!inputText.trim()) {
        showMessage('保存するデータがありません', 'error');
        return;
      }
      
      // 既存データがある場合は上書き確認
      const existingData = localStorage.getItem(`tl-assistant-slot-${slotNumber}`);
      if (existingData) {
        const existing = JSON.parse(existingData);
        const confirmMessage = `スロット${slotNumber}には既にデータが保存されています。\n` +
                             `保存日時: ${existing.timestamp}\n` +
                             `プレビュー: ${existing.preview}\n\n` +
                             `上書きしますか？`;
        if (!confirm(confirmMessage)) {
          return;
        }
      }
      
      // タイムライン関連設定を抽出
      const timelineSettings = {};
      for (const key of timeline_related_setting_keys) {
        if (settings.hasOwnProperty(key)) {
          timelineSettings[key] = settings[key];
        }
      }
      
      const saveData = {
        data: inputText,
        settings: timelineSettings,
        timestamp: new Date().toLocaleString('ja-JP'),
        preview: inputText.substring(0, 50) + (inputText.length > 50 ? '...' : '')
      };
      
      localStorage.setItem(`tl-assistant-slot-${slotNumber}`, JSON.stringify(saveData));
      showMessage(`スロット${slotNumber}に保存しました（設定も含む）`, 'success');
      
      // プレビューを更新
      updateSlotPreview(slotNumber);
    }

    /**
     * confirmOverwriteCurrentInput - 現在の入力データの上書き確認
     * @param {string} actionDescription - 実行する操作の説明
     * @returns {boolean} ユーザーが続行を選択した場合はtrue
     */
    function confirmOverwriteCurrentInput(actionDescription) {
      const currentInput = document.getElementById('timelineInput').value;
      if (currentInput.trim()) {
        const currentPreview = currentInput.substring(0, 50) + (currentInput.length > 50 ? '...' : '');
        const confirmMessage = `現在のタイムライン入力データが${actionDescription}によって消去されます。\n` +
                             `現在のデータ: ${currentPreview}\n\n` +
                             `続行しますか？`;
        return confirm(confirmMessage);
      }
      return true;
    }

    /**
     * loadFromSlot - スロット別localStorageからタイムラインデータを読み込み
     * @param {number} slotNumber - 読み込み元スロット番号（1-10）
     * 現在の入力データがある場合は上書き警告を表示
     * 読み込み後は自動更新を実行してタイムラインを処理
     */
    function loadFromSlot(slotNumber) {
      const savedDataStr = localStorage.getItem(`tl-assistant-slot-${slotNumber}`);
      if (!savedDataStr) {
        showMessage(`スロット${slotNumber}にデータがありません`, 'error');
        return;
      }
      
      // 現在の入力データがある場合は上書き警告
      if (!confirmOverwriteCurrentInput('読み込み')) {
        return;
      }
      
      try {
        const saveData = JSON.parse(savedDataStr);
        document.getElementById('timelineInput').value = saveData.data;
        
        // 設定データがある場合は読み込み
        if (saveData.settings) {
          applyLoadedSettings(saveData.settings);
          // 設定UIを更新
          updateActiveButtons();
          saveSettings(); // 現在の設定を保存
          showMessage(`スロット${slotNumber}からデータと設定を読み込みました (保存日時: ${saveData.timestamp})`, 'success');
        } else {
          showMessage(`スロット${slotNumber}からデータを読み込みました (保存日時: ${saveData.timestamp})`, 'success');
        }
        
        // 自動更新を使用して処理を実行
        triggerAutoUpdate();
      } catch (error) {
        showMessage(`スロット${slotNumber}のデータが破損しています`, 'error');
      }
    }

    /**
     * saveToLocal - 旧関数（互換性のため残す）
     * saveToSlot(1)のエイリアス
     */
    function saveToLocal() {
      saveToSlot(1);
    }

    /**
     * loadFromLocal - 旧関数（互換性のため残す）  
     * loadFromSlot(1)のエイリアス
     */
    function loadFromLocal() {
      loadFromSlot(1);
    }

    // =============================================================================
    // 🔧 初期化・設定管理
    // =============================================================================
    
    /**
     * 初期化 - DOMContentLoadedイベントハンドラ
     * アプリケーションの起動時に必要な初期化処理を順次実行
     * 外部ライブラリの読み込み確認、設定復元、UI初期化を行う
     */
    document.addEventListener('DOMContentLoaded', function() {
      // スクリプトの読み込み完了を待つ
      setTimeout(() => {
        console.log('Checking dependencies...');
        console.log('window.Utilities:', typeof window.Utilities);
        console.log('window.TLCommon:', typeof window.TLCommon);
        console.log('window.InputProcessor:', typeof window.InputProcessor);
        console.log('window.TLEditor:', typeof window.TLEditor);
        console.log('window.TimelineFormatter:', typeof window.TimelineFormatter);
        
        // 必要なライブラリの読み込み確認
        checkDependencies();
        
        // バフデータを読み込み
        loadBuffData();
        
        // 保存された設定を復元
        loadSettings();
        
        // 設定ボタンの初期化
        setupSettingsButtons();
        updateActiveButtons();
        
        // 自動更新のためのイベントリスナーを設定
        setupAutoUpdate();
        
        // 自動更新ボタンの初期状態を設定
        const autoUpdateButton = document.getElementById('autoUpdateToggle');
        if (autoUpdateEnabled) {
          autoUpdateButton.classList.add('active');
        }
        
        // 全スロットのプレビューを初期化
        updateAllSlotPreviews();
        
        // 空のタイムラインテーブルを表示
        document.getElementById('timelineOutput').innerHTML = generateEmptyTimelineTable();
      }, 200); // 少し長めに待機してライブラリの読み込み完了を確保
    });

    /**
     * loadBuffData - バフデータの読み込み
     * buffs.jsから提供されるバフ効果データをグローバル変数に設定
     * バフ計算に必要な基礎データを初期化する
     */
    function loadBuffData() {
      // buffs.jsから直接読み込み済み
      buffData = window.BUFF_DATA || null;
      
      // デバッグ用ログ - AI向け指示：これは残す
      if (buffData) {
        console.log('バフデータ読み込み完了:', buffData);
      } else {
        console.error('バフデータが見つかりません。buffs.jsが正しく読み込まれているか確認してください。');
      }
    }

    /**
     * setupAutoUpdate - 自動更新機能の設定
     * タイムライン入力欄の変更を監視し、500ms後に自動でタイムライン処理を実行
     * 連続入力時はタイマーをリセットして無駄な処理を防ぐ
     */
    function setupAutoUpdate() {
      // タイムライン入力欄の変更を監視
      const timelineInput = document.getElementById('timelineInput');
      timelineInput.addEventListener('input', function() {
        if (autoUpdateEnabled) {
          clearTimeout(autoUpdateTimer);
          autoUpdateTimer = setTimeout(() => {
            processTimelineWithErrorHandling();
          }, 500); // 500ms後に実行（連続入力への対応）
        }
      });

      console.log('自動更新イベントリスナーを設定しました');
    }

    /**
     * setupSettingsButtons - 設定ボタンのイベントリスナー初期化
     * 各種設定ボタン（戦闘時間、SS、コスト等）にクリックイベントを設定
     * 設定変更時は自動保存と自動更新を実行する
     */
    function setupSettingsButtons() {
      // 戦闘時間ボタンの設定
      const ttButtons = Array.from(document.querySelectorAll('.btn[data-tt]'));
      ttButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          settings.battle_time = Number(btn.dataset.tt);
          updateActiveButtons();
          saveSettings(); // 設定を自動保存
          triggerAutoUpdate();
        });
      });

      // SSボタンの設定
      const ssButtons = Array.from(document.querySelectorAll('.btn[data-ss]'));
      ssButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          settings.ss_enabled = btn.dataset.ss === 'on';
          updateActiveButtons();
          saveSettings(); // 設定を自動保存
          triggerAutoUpdate();
        });
      });

      // 最大コストボタンの設定
      const limitButtons = Array.from(document.querySelectorAll('.btn[data-limit]'));
      limitButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          settings.max_cost = Number(btn.dataset.limit);
          updateActiveButtons();
          saveSettings(); // 設定を自動保存
          triggerAutoUpdate();
        });
      });

      // 行頭数字解釈ボタンの設定
      const numberButtons = Array.from(document.querySelectorAll('.btn[data-number]'));
      numberButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          settings.number_interpretation = btn.dataset.number;
          updateActiveButtons();
          saveSettings(); // 設定を自動保存
          triggerAutoUpdate();
        });
      });

      // 時間表示形式ボタンの設定
      const displayButtons = Array.from(document.querySelectorAll('.btn[data-display]'));
      displayButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          settings.time_display_format = btn.dataset.display;
          updateActiveButtons();
          saveSettings(); // 設定を自動保存
          triggerAutoUpdate();
        });
      });

      // +/-解釈ボタンの設定
      const modifierButtons = Array.from(document.querySelectorAll('.btn[data-modifier]'));
      modifierButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          settings.modifier_always_forward = btn.dataset.modifier;
          updateActiveButtons();
          saveSettings(); // 設定を自動保存
          triggerAutoUpdate();
        });
      });

      // セイア固有2ボタンの設定
      const seiaButtons = Array.from(document.querySelectorAll('.btn[data-seia]'));
      seiaButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          settings.seia_koyuu2 = btn.dataset.seia;
          updateActiveButtons();
          saveSettings(); // 設定を自動保存
          triggerAutoUpdate();
        });
      });

      // カノエボタンの設定
      const kanoeButtons = Array.from(document.querySelectorAll('.btn[data-kanoe]'));
      kanoeButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          settings.kanoe_ss = btn.dataset.kanoe;
          updateActiveButtons();
          saveSettings(); // 設定を自動保存
          triggerAutoUpdate();
        });
      });

      // チェリノボタンの設定
      const cherinoButtons = Array.from(document.querySelectorAll('.btn[data-cherino]'));
      cherinoButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          settings.cherino_ss = btn.dataset.cherino;
          updateActiveButtons();
          saveSettings(); // 設定を自動保存
          triggerAutoUpdate();
        });
      });

      // 特殊コマンドボタンの設定
      const specialButtons = Array.from(document.querySelectorAll('.btn[data-special]'));
      specialButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          settings.special_command_accepted = btn.dataset.special;
          updateActiveButtons();
          saveSettings(); // 設定を自動保存
          triggerAutoUpdate();
        });
      });
    }

    /**
     * updateActiveButtons - アクティブボタンの表示更新
     * 現在の設定値に基づいて各設定ボタンのアクティブ状態を更新
     * 現在値の表示テキストも同時に更新する
     */
    function updateActiveButtons() {
      // 戦闘時間ボタンのアクティブ状態更新
      const ttButtons = Array.from(document.querySelectorAll('.btn[data-tt]'));
      ttButtons.forEach(btn => {
        const v = Number(btn.dataset.tt);
        btn.classList.toggle('active', v === settings.battle_time);
      });
      document.getElementById('currentTT').textContent = `(現在: ${settings.battle_time}秒)`;

      // SSボタンのアクティブ状態更新
      const ssButtons = Array.from(document.querySelectorAll('.btn[data-ss]'));
      ssButtons.forEach(btn => {
        const isOn = btn.dataset.ss === 'on';
        btn.classList.toggle('active', isOn === settings.ss_enabled);
      });
      document.getElementById('currentSS').textContent = `(現在: ${settings.ss_enabled ? 'オン' : 'オフ'})`;

      // 最大コストボタンのアクティブ状態更新
      const limitButtons = Array.from(document.querySelectorAll('.btn[data-limit]'));
      limitButtons.forEach(btn => {
        const v = Number(btn.dataset.limit);
        btn.classList.toggle('active', v === settings.max_cost);
      });
      document.getElementById('currentLimit').textContent = `(現在: ${settings.max_cost})`;

      // 行頭数字解釈ボタンのアクティブ状態更新
      const numberButtons = Array.from(document.querySelectorAll('.btn[data-number]'));
      numberButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.number === settings.number_interpretation);
      });
      document.getElementById('currentNumber').textContent = `(現在: ${settings.number_interpretation === 'time' ? 'タイム' : 'コストタイミング'})`;

      // 時間表示形式ボタンのアクティブ状態更新
      const displayButtons = Array.from(document.querySelectorAll('.btn[data-display]'));
      displayButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.display === settings.time_display_format);
      });
      document.getElementById('currentDisplay').textContent = `(現在: ${settings.time_display_format === 'backward' ? 'ゲーム内表示' : '経過時間'})`;

      // +/-解釈ボタンのアクティブ状態更新
      const modifierButtons = Array.from(document.querySelectorAll('.btn[data-modifier]'));
      modifierButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.modifier === settings.modifier_always_forward);
      });
      document.getElementById('currentModifier').textContent = `(現在: ${settings.modifier_always_forward === 'yes' ? '常に秒後/秒前' : '表示形式に依存'})`;

      // セイア固有2ボタンのアクティブ状態更新
      const seiaButtons = Array.from(document.querySelectorAll('.btn[data-seia]'));
      seiaButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.seia === settings.seia_koyuu2);
      });
      document.getElementById('currentSeia').textContent = `(現在: ${settings.seia_koyuu2 === 'yes' ? 'あり' : 'なし'})`;

      // カノエボタンのアクティブ状態更新
      const kanoeButtons = Array.from(document.querySelectorAll('.btn[data-kanoe]'));
      kanoeButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.kanoe === settings.kanoe_ss);
      });
      const kanoeLabels = {
        '0': 'なし',
        '1': '本人のみ',
        '2': '本人+1',
        '3': '本人+2',
        '4': '本人+3'
      };
      document.getElementById('currentKanoe').textContent = `(現在: ${kanoeLabels[settings.kanoe_ss] || 'なし'})`;

      // チェリノボタンのアクティブ状態更新
      const cherinoButtons = Array.from(document.querySelectorAll('.btn[data-cherino]'));
      cherinoButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.cherino === settings.cherino_ss);
      });
      const cherinoLabels = {
        '0': 'なし',
        '1': '本人のみ',
        '2': '本人+1',
        '3': '本人+2',
        '4': '本人+3'
      };
      // AI向け指示：これは残す
      document.getElementById('currentCherino').textContent = `(現在: ${cherinoLabels[settings.cherino_ss] || 'なし'})`;

      // 特殊コマンドボタンのアクティブ状態更新
      const specialButtons = Array.from(document.querySelectorAll('.btn[data-special]'));
      specialButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.special === settings.special_command_accepted);
      });
      document.getElementById('currentSpecial').textContent = `(現在: ${settings.special_command_accepted === 'yes' ? 'はい' : 'いいえ'})`;
    }

    // =============================================================================
    // ⚙️ タイムライン処理
    // =============================================================================

    /**
     * triggerAutoUpdate - 自動更新のトリガー
     * 設定変更時やユーザー入力時に呼び出され、短時間後にタイムライン処理を実行
     * 100msの遅延で即座に反映（設定変更用）
     */
    function triggerAutoUpdate() {
      if (autoUpdateEnabled) {
        clearTimeout(autoUpdateTimer);
        autoUpdateTimer = setTimeout(() => {
          processTimelineWithErrorHandling();
        }, 100); // 設定変更はすぐに反映
      }
    }

    /**
     * processTimelineWithErrorHandling - エラーハンドリング付きタイムライン処理
     * 自動更新用のラッパー関数。エラーが発生してもユーザーには通知せず、
     * コンソールログのみに記録する
     */
    async function processTimelineWithErrorHandling() {
      try {
        const input = document.getElementById('timelineInput').value.trim();
        if (input) {
          // 自動更新中であることを示すフラグ
          const isAutoUpdate = true;
          await processTimeline(isAutoUpdate);
        } else {
          // 入力が空の場合は空のテーブルを表示
          document.getElementById('timelineOutput').innerHTML = generateEmptyTimelineTable();
          document.getElementById('timelineSection').style.display = 'none';
        }
      } catch (error) {
        console.warn('自動更新中にエラーが発生しました:', error);
        // 自動更新でのエラーは静かに処理（ユーザーに警告は表示しない）
      }
    }

    /**
     * checkDependencies - 必要な外部ライブラリの読み込み確認
     * @returns {boolean} 全ての依存関係が満たされている場合はtrue
     * 
     * 以下のライブラリとその主要関数の存在を確認:
     * - utilities.js: parseTimeToSeconds等のユーティリティ関数
     * - input-processor.js: createInputJSON関数  
     * - tl-editor.js: TimelineProcessorクラス
     * - timeline-formatter.js: generateTimelineHTML関数
     */
    function checkDependencies() {
      const missing = [];
      const details = [];
      
      // utilities.jsの確認
      if (typeof window.Utilities === 'undefined') {
        missing.push('utilities.js');
        details.push('window.Utilities が undefined');
      } else {
        details.push('✓ utilities.js OK');
      }
      
      // input-processor.jsの確認
      if (typeof window.InputProcessor === 'undefined') {
        missing.push('input-processor.js');
        details.push('window.InputProcessor が undefined');
      } else {
        if (typeof window.InputProcessor.createInputJSON === 'undefined') {
          missing.push('input-processor.js (createInputJSON関数なし)');
          details.push('window.InputProcessor.createInputJSON が undefined');
        } else {
          details.push('✓ input-processor.js OK');
        }
      }
      
      // tl-editor.jsの確認
      if (typeof window.TLEditor === 'undefined') {
        missing.push('tl-editor.js');
        details.push('window.TLEditor が undefined');
      } else {
        // TimelineProcessorクラスの存在確認
        if (typeof window.TLEditor.TimelineProcessor === 'undefined') {
          missing.push('tl-editor.js (TimelineProcessorクラスなし)');
          details.push('window.TLEditor.TimelineProcessor が undefined');
        } else {
          details.push('✓ tl-editor.js OK (TimelineProcessor利用可能)');
        }
      }

      // timeline-formatter.jsの確認
      if (typeof window.TimelineFormatter === 'undefined') {
        missing.push('timeline-formatter.js');
        details.push('window.TimelineFormatter が undefined');
      } else {
        if (typeof window.TimelineFormatter.generateTimelineHTML === 'undefined') {
          missing.push('timeline-formatter.js (generateTimelineHTML関数なし)');
          details.push('window.TimelineFormatter.generateTimelineHTML が undefined');
        } else {
          details.push('✓ timeline-formatter.js OK');
        }
      }
      
      // 詳細情報をコンソールに出力
      console.log('Dependencies check:', details);
      
      if (missing.length > 0) {
        const errorMsg = `必要なライブラリが読み込まれていません: ${missing.join(', ')}\n\n詳細:\n${details.join('\n')}`;
        showMessage(errorMsg, 'error');
        return false;
      }
      
      return true;
    }

    /**
     * processTimeline - メインのタイムライン処理関数
     * @param {boolean} isAutoUpdate - 自動更新モードかどうか（エラー表示の制御）
     * 
     * 処理の流れ:
     * 1. 依存関係の確認
     * 2. 設定値の収集
     * 3. 入力データの処理（InputProcessor）
     * 4. タイムライン生成（TLEditor.TimelineProcessor）
     * 5. 結果の表示（HTML、テキスト、デバッグ情報、JSON）
     */
    async function processTimeline(isAutoUpdate = false) {
      try {
        // 依存関係の確認
        if (!checkDependencies()) {
          return;
        }

        // バフデータが読み込まれていない場合は読み込む
        if (!buffData) {
          console.log('バフデータが未読み込みのため、読み込み中...');
          loadBuffData();
        }

        const input = document.getElementById('timelineInput').value.trim();
        console.log('入力データ:', JSON.stringify(input));
        
        if (!input) {
          if (!isAutoUpdate) {
            showMessage('タイムラインを入力してください', 'error');
          }
          return;
        }

        ///////////////////////////////////////////////////////
        // 【重要】グローバル設定オブジェクトを直接使用
        ///////////////////////////////////////////////////////

        // 入力処理フェーズ
        try {
          console.log('InputProcessor.createInputJSON 実行開始');
          const processedTimeline = window.InputProcessor.createInputJSON(input, settings);
          console.log('処理された入力データ:', processedTimeline);
          
          if (!processedTimeline || processedTimeline.length === 0) {
            throw new Error('入力処理の結果が空です');
          }
          
          currentInputJSON = {
            timeline: processedTimeline,
            metadata: {
              input_length: processedTimeline.length,
              processed_at: new Date().toISOString()
            }
          };
          console.log('currentInputJSON:', currentInputJSON);
          if (!isAutoUpdate) {
            showMessage('入力処理完了', 'success');
          }
        } catch (inputError) {
          throw new Error(`入力処理エラー: ${inputError.message}`);
        }

        // タイムライン生成フェーズ
        try {
          console.log('TimelineProcessor作成時のbuffData:', buffData);
          const processor = new window.TLEditor.TimelineProcessor(currentInputJSON, settings, buffData);
          currentTimelineJSON = processor.createTimelineJSON();
          
          console.log('生成されたtimeline_json:', currentTimelineJSON);
          console.log('additional_events:', currentTimelineJSON.additional_events);
          
          if (!isAutoUpdate) {
            showMessage('タイムライン生成完了', 'success');
          }
        } catch (timelineError) {
          throw new Error(`タイムライン生成エラー: ${timelineError.message}`);
        }

        // 結果表示フェーズ
        displayTimelineResults(currentTimelineJSON);
        displayDebugInfo(currentInputJSON, currentTimelineJSON);
        displayJSONOutput(currentTimelineJSON);

      } catch (error) {
        if (!isAutoUpdate) {
          showMessage(`エラー: ${error.message}`, 'error');
        }
        console.error('タイムライン処理エラー:', error);
      }
    }

    /**
     * generateTimelineTableHeader - タイムラインテーブルのヘッダーを生成
     * @returns {string} テーブルヘッダーHTML
     */
    function generateTimelineTableHeader() {
      return `<table>
          <thead>
            <tr>
              <th>経過時間</th>
              <th>フレーム</th>
              <th>イベント名</th>
              <th>使用コスト</th>
              <th>残りコスト</th>
              <th>あふれたコスト</th>
              <th>残りコストポイント</th>
              <th>総コスト回復力</th>
            </tr>
          </thead>
          <tbody>`;
    }

    /**
     * generateEmptyTimelineTable - 空のタイムラインテーブルを生成
     * @returns {string} 空のテーブルHTML
     */
    function generateEmptyTimelineTable() {
      return generateTimelineTableHeader() + `
            <tr>
              <td colspan="8" style="text-align: center; color: #6b7280; font-style: italic;">
                タイムラインを入力して「タイムライン生成」ボタンを押してください
              </td>
            </tr>
          </tbody>
        </table>
        
        <div class="setting-comment">
          コストポイント：内部的にはコスト管理は整数値で管理されていると想定します。1フレームごとに総コスト回復力と等しい数値を獲得しているとし、その蓄積された値をコストポイントと呼ぶことにします。300,000コストポイント ＝ 1コストです。
        </div>`;
    }

    // =============================================================================
    // 📊 表示・出力
    // =============================================================================
    
    /**
     * displayTimelineResults - タイムライン結果の表示
     * @param {Object} timelineJSON - タイムラインJSONデータ
     * 
     * HTMLとテキスト形式の両方でタイムラインを生成・表示
     * イベント一覧テーブル、コストポイント詳細、追加イベントも含む
     */
    function displayTimelineResults(timelineJSON) {
      // タイムラインセクションを表示
      document.getElementById('timelineSection').style.display = 'block';
      
      // HTMLタイムライン表示
      try {
        const result = window.TimelineFormatter.generateTimelineNew(timelineJSON, {
          battle_time: settings.battle_time
        });
        document.getElementById('timelineDisplay').innerHTML = result.html;
      } catch (error) {
        console.error('タイムラインHTML生成エラー:', error);
        document.getElementById('timelineDisplay').innerHTML = '<p>タイムライン表示でエラーが発生しました: ' + error.message + '</p>';
      }
      
      // テキストタイムライン生成
      try {
        const result = window.TimelineFormatter.generateTimelineNew(timelineJSON, {
          battle_time: settings.battle_time
        });
        document.getElementById('timelineTextOutput').value = result.text;
      } catch (error) {
        console.error('タイムラインテキスト生成エラー:', error);
        document.getElementById('timelineTextOutput').value = 'タイムラインテキスト生成でエラーが発生しました: ' + error.message;
      }
      
      const output = document.getElementById('timelineOutput');
      
      // 詳細イベント一覧テーブルの生成
      let html = generateTimelineTableHeader();

      // 各イベントの詳細情報を表示
      for (const event of timelineJSON.timeline) {
        const costPoints = event.remaining_cost_points !== undefined ? event.remaining_cost_points.toLocaleString() : 'N/A';
        const totalCostRecovery = event.total_cost_recovery !== undefined ? event.total_cost_recovery.toLocaleString() : 'N/A';
        // timeプロパティがない場合はframeから計算
        const eventTime = event.time !== undefined ? event.time : (event.frame / 30);
        
        // あふれたコスト（オーバーフロー）の表示
        const overflowCost = event.overflow_cost !== undefined ? event.overflow_cost.toFixed(1) : '0.0';
        const overflowDisplay = parseFloat(overflowCost) > 0 ? 
          `<span class="cost-overflow">${overflowCost}</span>` : overflowCost;
        
        html += `
          <tr>
            <td>${eventTime.toFixed(3)}</td>
            <td>${event.frame}</td>
            <td style="text-align: left;">${event.event_name}</td>
            <td>${event.cost_used.toFixed(1)}</td>
            <td>${event.current_cost_display_only.toFixed(1)}</td>
            <td>${overflowDisplay}</td>
            <td style="color: #059669; font-family: monospace;">${costPoints}</td>
            <td style="color: #1976d2; font-family: monospace;">${totalCostRecovery}</td>
          </tr>
        `;
      }

      html += `
          </tbody>
        </table>
        
        <div class="setting-comment">
          コストポイント：内部的にはコスト管理は整数値で管理されていると想定します。1フレームごとに総コスト回復力と等しい数値を獲得しているとし、その蓄積された値をコストポイントと呼ぶことにします。300,000コストポイント ＝ 1コストです。
        </div>
      `;

      output.innerHTML = html;
    }

    /**
     * displayDebugInfo - デバッグ情報の表示
     * @param {Object} inputJSON - 入力処理結果のJSON
     * @param {Object} timelineJSON - タイムライン生成結果のJSON
     * 
     * 入力JSON構造と処理統計を表示して開発・デバッグを支援
     */
    function displayDebugInfo(inputJSON, timelineJSON) {
      const debug = document.getElementById('debugInfo');
      
      let html = `
        <h4>🔧 入力JSON構造</h4>
        <div class="json-output">${JSON.stringify(inputJSON, null, 2)}</div>
        
        <h4>📊 処理統計</h4>
        <ul>
          <li>入力行数: ${inputJSON.timeline.length}</li>
          <li>ラベル数: ${Object.keys(inputJSON.labels || {}).length}</li>
          <li>参照解決数: ${inputJSON.timeline.filter(row => row.reference).length}</li>
          <li>コスト計算行数: ${inputJSON.timeline.filter(row => row.cost > 0).length}</li>
        </ul>
      `;

      debug.innerHTML = html;
    }

    /**
     * displayJSONOutput - JSON出力の表示
     * @param {Object} timelineJSON - タイムラインJSONデータ
     * 
     * 整形されたJSONを表示し、クリップボードコピー機能を提供
     */
    function displayJSONOutput(timelineJSON) {
      const output = document.getElementById('jsonOutput');
      output.innerHTML = `
        <div class="json-output">${JSON.stringify(timelineJSON, null, 2)}</div>
        <button class="btn" onclick="copyToClipboard()" style="margin-top: 12px;">📋 クリップボードにコピー</button>
      `;
    }

    // =============================================================================
    // 🔧 ユーティリティ・UI
    // =============================================================================

    /**
     * showMessage - ユーザーへのメッセージ表示
     * @param {string} text - 表示するメッセージ
     * @param {string} type - メッセージタイプ（'info', 'success', 'error'）
     * 
     * エラーメッセージは手動で閉じるまで表示、成功メッセージは3秒で自動消去
     */
    function showMessage(text, type = 'info') {
      // 既存のメッセージを削除
      const existing = document.querySelector('.error-message, .success-message, .info-message');
      if (existing) existing.remove();

      const div = document.createElement('div');
      div.className = `${type}-message`;
      div.textContent = text;
      
      // エラーメッセージの場合は閉じるボタンを追加
      if (type === 'error') {
        const closeBtn = document.createElement('button');
        closeBtn.textContent = '✕';
        closeBtn.style.cssText = 'float: right; background: none; border: none; font-size: 1.2rem; cursor: pointer; color: inherit;';
        closeBtn.onclick = () => div.remove();
        div.appendChild(closeBtn);
        div.style.paddingRight = '40px';
      } else {
        // 成功メッセージは3秒後に自動削除
        setTimeout(() => div.remove(), 3000);
      }
      
      document.querySelector('.main-content').insertBefore(div, document.querySelector('.timeline-container'));
    }

    /**
     * toggleAccordion - アコーディオンUI の開閉切り替え
     * @param {HTMLElement} header - クリックされたヘッダー要素
     */
    function toggleAccordion(header) {
      const accordion = header.parentElement;
      accordion.classList.toggle('open');
    }

    /**
     * clearAll - 全データのクリア
     * 入力、出力、グローバル変数、タイマーを全てリセットする
     */
    function clearAll() {
      document.getElementById('timelineInput').value = '';
      document.getElementById('timelineOutput').innerHTML = generateEmptyTimelineTable();
      document.getElementById('timelineSection').style.display = 'none';
      currentTimelineJSON = null;
      currentInputJSON = null;
      
      // タイマーもクリア
      clearTimeout(autoUpdateTimer);
    }

    /**
     * loadSampleTimeline - サンプルタイムラインの読み込み
     * @param {number} sampleNumber - 読み込むサンプル番号（1-5）
     * 
     * 事前定義されたサンプルタイムラインを入力欄に設定し、自動更新を実行
     * AI向け指示：サンプル内容はそのまま維持すること
     */
    function loadSampleTimeline(sampleNumber) {
      // 現在の入力データがある場合は上書き警告
      if (!confirmOverwriteCurrentInput('サンプル読み込み')) {
        return;
      }
      
      let sample = '';
      
      switch(sampleNumber) {
        case 1:
          sample = `シュンNS -3.8 コスト回復表現可
[5]ナギサ 3 固有2ない場合6コス
[7]リオ 2
#seia - 1.900 本アリス 4 #a
カンナ[2] 順不同、スキルカードガチャ回避
02:37.800 水着セイア[3] #seia 
#a+4.000 Ｃアリス 3 #a2
#a2+4 本アリス 4 #a3
#a3+2.833 〆

！セイアのタイム指定を[3]にするとエラーが出ます。試してみてください
！行頭に「！」を書くとコメント行になり無視されます
!全角でも半角でもいいですが、絵文字はダメです❗`;
          break;
          
        case 2:
          sample = `
水着ホシノ[5]
セイア[3]
リオ[2]
キサキ[3]
[6]ミカ[3] #ミカ1
ドアル[3]
#ミカ1 +1.1 Ｃミカ[3] #ミカ2
セイア[3]
#ミカ2 +1.3 ミカ[3] #ミカ3`;
          break;
          
        case 3:
          sample = `1:15.867 イブキ[3] #イブキ
2:02.433 イロハ 6 #イロハ
[5.85]サツキ 5
[0.1]チアキ 6 #チアキ
#イロハ - 2.5 マコト 6 #イロハ2
#サツキ+1.1 イブキ 3`;;
          break;
          
        case 4:
          sample = `セイア[3]
ハレキャンプ[2]
水着ホシノ[5]
セイア[3]
ハレキャンプ[2]
セイア[3]
ハレキャンプ[2]
セイア[3]
ハレキャンプ[2]
水着ヒフミ[10]
セイア[3]
ハレキャンプ[2]
セイア[3]
ハレキャンプ[2]`;
          break;
          
        case 5:
          sample = `水着ホシノ[5]
[9.95]ミカ[6]
キサキ[3]
アコ[3]
水着ホシノ[5]
バンドヨシミ[10]
[9.95]ミカ[6]
キサキ[3]
アコ[3]
水着ホシノ[5]`;
          break;

        case 6:
          sample = `！行頭に「！」を書くとコメント行になり無視されます
!全角でも半角でもいいですが、絵文字はダメです❗
！このサンプルを試したい場合はサンプル6を押してください
[5.0]水着ナギサ[3]
[6]ハレ[2] 上振れてSSで輝ペロロ倒すとリスタ
[8.5]カノエ[3]
[9.9]カヨコ[2]
[9.9]臨戦[6]
03:22 キサキ[3]
03:18.433 ナギサ[3]
03:14 ハレ[2] 
3:08.5 臨戦[6]
[2]カヨコ[2]
[7]ナギサ[3]
[5]ハレ[2]
[8.8]右端輝きペロロが振り返る直前臨戦[6]
キサキ[3]
[4]カヨコ歩きはじめたら、足止めカヨコEX[2]
カノエ[3]
[4]NS後ハレ[2]
[3]ナギサ[3]
[9.9]臨戦[6]
キサキ[3]
カヨコ[2]
01:53.900 ハレ[2]
[1]臨戦[6]`;
          break;

        case 7:
          sample = `2:45 コスト回復力増加 全体 500 30秒
2:42 イオリ 3
2:40 キサキ 3
[8]ミカ 6
2:25 コスト回復力増加 イオリ 100 5秒
2:10 セイア[3]
2:05 コスト回復力増加 セイア 500 20秒
水着ホシノ[5]
[10]ミカ[6]
キサキ[3]
アコ[3]
アイドルマリー[2]
[10]ミカ[6]
キサキ[3]
アコ[3]
`;
          break;

        case 8:
          sample = `ボス：ゲブラ
AUTO アイドルマリー 2
3:51.900 ラジエーター起動
3:41.200 サツキ 6
`;
          break;

        default:
          sample = '';
      }
      
      if (sample) {
        document.getElementById('timelineInput').value = sample;
        showMessage(`サンプル${sampleNumber}を読み込みました`, 'success');
        
        // 自動更新を使用して処理を実行
        triggerAutoUpdate();
      }
    }

    /**
     * toggleAutoUpdate - 自動更新機能のON/OFF切り替え
     * ボタンの表示状態を更新し、有効時は現在の入力で即座に更新を実行
     */
    function toggleAutoUpdate() {
      autoUpdateEnabled = !autoUpdateEnabled;
      const button = document.getElementById('autoUpdateToggle');
      
      if (autoUpdateEnabled) {
        button.textContent = '🔄 自動更新: ON';
        button.classList.add('active');
        showMessage('自動更新を有効にしました', 'success');
        
        // 自動更新を有効にした時に現在の内容で即座に更新
        const input = document.getElementById('timelineInput').value.trim();
        if (input) {
          triggerAutoUpdate();
        }
      } else {
        button.textContent = '🔄 自動更新: OFF';
        button.classList.remove('active');
        showMessage('自動更新を無効にしました', 'info');
        
        // タイマーをクリア
        clearTimeout(autoUpdateTimer);
      }
    }

    // =============================================================================
    // 🚨 重複関数 - TODO: セーブ・ロード統合後に削除予定
    // =============================================================================
    // 📋 コピー・クリップボード
    // =============================================================================

    /**
     * copyToClipboard - タイムラインJSONをクリップボードにコピー
     * 現在生成されているタイムラインJSONを整形してクリップボードに送る
     */
    function copyToClipboard() {
      if (!currentTimelineJSON) return;
      
      navigator.clipboard.writeText(JSON.stringify(currentTimelineJSON, null, 2))
        .then(() => showMessage('クリップボードにコピーしました', 'success'))
        .catch(() => showMessage('コピーに失敗しました', 'error'));
    }

    /**
     * copyTimelineText - タイムラインテキストをクリップボードにコピー
     * 生成されたテキスト形式タイムラインをクリップボードに送る
     * モバイル端末での選択にも対応
     */
    function copyTimelineText() {
      const textarea = document.getElementById('timelineTextOutput');
      textarea.select();
      textarea.setSelectionRange(0, 99999); // モバイル対応
      
      navigator.clipboard.writeText(textarea.value)
        .then(() => showMessage('タイムラインテキストをコピーしました', 'success'))
        .catch(() => showMessage('コピーに失敗しました', 'error'));
    }
  </script>
</body>
</html>

